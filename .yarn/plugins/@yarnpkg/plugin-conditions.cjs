/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-conditions",
factory: function (require) {
var plugin;plugin=(()=>{"use strict";var e={901:(e,t,n)=>{n.r(t),n.d(t,{default:()=>k});const r=require("@yarnpkg/core");function o(e){return e.startsWith("condition:")}function i(e){const t=e.match(/^condition:\s*(?<test>\w+)\s*\?\s*(?<consequent>[^\s:]*)\s*:\s*(?<alternate>[^\s:#]*)\s*(?:#(.*))?$/);let n;n=null!==t?t.groups:r.structUtils.parseRange(e).params;const{test:o,consequent:i,alternate:s}=n;return{test:o,consequent:i||null,alternate:s||null}}function s(e){return i(e.range)}function a(e){return i(e.reference)}function c(e,t,n,o){if(!o)return null;const i=r.structUtils.makeIdent("",`${n}-${e}-${t}`);return r.structUtils.makeDescriptor(i,`npm:${n}@${o}`)}function u({test:e,consequent:t,alternate:n,hash:r}){return`condition:${e}?${t||""}:${n||""}#${r||""}`}function l(e,{test:t,consequent:n,alternate:o,hash:i}){return r.structUtils.makeLocator(e,u({test:t,consequent:n,alternate:o,hash:i}))}function p(e,t,n,o){return r.hashUtils.makeHash(String(1),e,t||"-",n||"-",o?"1":"0").slice(0,6)}const f={conditions:{description:"",type:r.SettingsType.MAP,valueDefinition:{description:"",type:r.SettingsType.SHAPE,properties:{source:{description:"",type:r.SettingsType.STRING,default:"env"},default:{description:"",type:r.SettingsType.BOOLEAN,default:!1}}}}};function d(e,t){if(!e.configuration.get("conditions").has(t))throw new Error(`Unknown condition: ${t}. You must add it to your .yarnrc.yml file.`)}function g(e,t){return d(e,t),e.configuration.get("conditions").get(t).get("default")}function h(e,t){var n;d(e,t);const r=e.configuration.get("conditions").get(t),o=r.get("source"),i=r.get("default");if("env"!==o)throw new Error("The only supported configuration source is 'env'");return null!==(n=(s=process.env[t])&&"false"!==s&&"0"!==s)&&void 0!==n?n:i;var s}const m=require("@yarnpkg/fslib"),y=require("@yarnpkg/libzip");const v=["dependencies","devDependencies","peerDependencies"];const k={configuration:f,fetchers:[class{supports(e){return o(e.reference)}getLocalPath(){return null}async fetch(e,t){const n=t.checksums.get(e.locatorHash)||null,[o,i,s]=await t.cache.fetchPackageFromCache(e,n,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e,r.structUtils.prettyLocator(t.project.configuration,e)+" can't be found in the cache and will be fetched from the disk"),loader:()=>this.generateConditionPackage(e,t),skipIntegrityCheck:t.skipIntegrityCheck});return{packageFs:o,releaseFs:i,prefixPath:r.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(),checksum:s}}async generateConditionPackage(e,t){const{test:n,consequent:o,alternate:i}=a(e),s=g(t.project,n),{name:c}=e,u=p(n,o,i,s),[l,f]=await Promise.all([m.xfs.mktempPromise(),(0,y.getLibzipPromise)()]),d=m.ppath.join(l,"condition.zip"),h=r.structUtils.getIdentVendorPath(e),v=new m.ZipFS(d,{libzip:f,create:!0,level:t.project.configuration.get("compressionLevel")});return await v.mkdirpPromise(h),await Promise.all([this.writeFileStaticTime(v,m.ppath.join(h,"package.json"),JSON.stringify({version:"0.0.0-condition-"+u,dependencies:{[`${c}-${n}-true`]:o,[`${c}-${n}-false`]:i}})),this.writeFileStaticTime(v,m.ppath.join(h,"index.js"),`// env vars from the cli are always strings, so !!ENV_VAR returns true for "false"\nfunction bool(value) {\n  if (value == null) return ${s};\n  return value && value !== "false" && value !== "0";\n}\n\nmodule.exports = bool(process.env[${JSON.stringify(n)}])\n  ? require(${JSON.stringify(`${c}-${n}-true`)})\n  : require(${JSON.stringify(`${c}-${n}-false`)});\n`)]),v}async writeFileStaticTime(e,t,n){await e.writeJsonPromise(t,n),await e.utimesPromise(t,15805116e5,15805116e5)}}],resolvers:[class{supportsDescriptor(e){return o(e.range)}supportsLocator(e){return o(e.reference)}shouldPersistResolution(){return!1}bindDescriptor(e){return e}getResolutionDependencies(e){const{test:t,consequent:n,alternate:r}=s(e);return[c(t,!0,e.name,n),c(t,!1,e.name,r)].filter(Boolean)}async getCandidates(e,t,n){const{test:r,consequent:o,alternate:i}=s(e);return[l(e,{test:r,consequent:o,alternate:i,hash:p(r,o,i,g(n.project,r))})]}async getSatisfying(){return null}async resolve(e,t){const{test:n,consequent:o,alternate:i}=a(e),s=p(n,o,i,g(t.project,n)),u=c(n,!0,e.name,o),l=c(n,!1,e.name,i);return{...e,version:"0.0.0-condition-"+s,languageName:t.project.configuration.get("defaultLanguageName"),linkType:r.LinkType.HARD,dependencies:new Map([u&&[u.identHash,u],l&&[l.identHash,l]].filter(Boolean)),peerDependencies:new Map,dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:null}}}],hooks:{beforeWorkspacePacking:function(e,t){const{project:n}=e;for(const i of v){const a=e.manifest.getForScope(i).values();for(const e of a){if(!o(e.range))continue;const{test:a,consequent:c,alternate:u}=s(e),l=h(n,a)?c:u,p=r.structUtils.stringifyIdent(e);l?t[i][p]=l:delete t[i][p]}}}}}}},t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={exports:{}};return e[r](o,o.exports,n),o.exports}return n.d=(e,t)=>{for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n(901)})();
return plugin;
}
};