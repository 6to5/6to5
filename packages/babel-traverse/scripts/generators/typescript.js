"use strict";

const t = require("../../../babel-types");
// const utils = require("../../../../scripts/generators/utils");

const visitorEntries = [];
const isEntries = [];
const assertEntries = [];

for (const type of t.TYPES) {
  visitorEntries.push(`  ${type}?: VisitNode<S, t.${type}>;`);
  assertEntries.push(`  assert${type}(opts?: object): void;`);

  let isReturn = "boolean";
  if (t.NODE_FIELDS[type]) {
    isReturn = `this is NodePath<t.${type}>`;
  }
  isEntries.push(`  is${type}(opts?: object): ${isReturn};`);
}

const code = `// NOTE: This file is autogenerated. Do not modify.
// See scripts/generators/typescript.js for script used.

import * as t from '@babel/types';

export class NodePath<T = t.Node> {
  constructor(hub: Hub, parent: t.Node);
  parent: t.Node;
  hub: Hub;
  contexts: TraversalContext[];
  data: object;
  shouldSkip: boolean;
  shouldStop: boolean;
  removed: boolean;
  state: any;
  opts: object;
  skipKeys: object;
  parentPath: NodePath;
  context: TraversalContext;
  container: object | object[];
  listKey: string;
  inList: boolean;
  parentKey: string;
  key: string;
  node: T;
  scope: Scope;
  type: T extends undefined | null ? string | null : string;
  typeAnnotation: object;

  getScope(scope: Scope): Scope;
  setData(key: string, val: any): any;
  getData(key: string, def?: any): any;
  buildCodeFrameError<TError extends Error>(msg: string,
    Error?: new (msg: string) => TError): TError;
  traverse<T = t.Node>(visitor: Visitor<T>, state: T): void;
  set(key: string, node: t.Node): void;
  getPathLocation(): string;
  debug(buildMessage: () => string): void;
  toString(): string;

  findParent(callback: (path: NodePath) => boolean): NodePath;
  find(callback: (path: NodePath) => boolean): NodePath;
  getFunctionParent(): NodePath<t.Function>;
  getStatementParent(): NodePath<t.Statement>;
  getEarliestCommonAncestorFrom(paths: NodePath[]): NodePath[];
  getDeepestCommonAncestorFrom(
    paths: NodePath[],
    filter?: (deepest: t.Node, i: number, ancestries: NodePath[]) => NodePath
  ): NodePath;
  getAncestry(): NodePath[];
  isAncestor(maybeDescendant: NodePath): boolean;
  isDescendant(maybeAncestor: NodePath): boolean;
  inType(...candidateTypes: string[]): boolean;

  shareCommentsWithSiblings(): void;
  addComment(type: string, content: string, line?: boolean): void;
  addComments(type: string, comments: any[]): void;

  call(key: string): boolean;
  isBlacklisted(): boolean;
  visit(): boolean;
  skip(): void;
  skipKey(key: string): void;
  stop(): void;
  setScope(): void;
  setContext(context: TraversalContext): NodePath<T>;
  resync(): void;
  popContext(): void;
  pushContext(context: TraversalContext): void;
  setup(parentPath: NodePath,
    container: object | object[],
    listKey: string,
    key: string): void;
  setKey(key: string): void;
  requeue(pathToQueue?: NodePath): void;

  toComputedKey(): object;
  ensureBlock(): t.Node;
  arrowFunctionToShadowed(): void;
  unwrapFunctionEnvironment(): void;
  arrowFunctionToExpression(opts?: {
    allowInsertArrow?: boolean,
    specCompliant?: boolean
  }): void;

  evaluateTruthy(): boolean;
  evaluate(): { confident: boolean; value: any };

  getOpposite(): NodePath;
  getCompletionRecords(): NodePath[];
  getSibling(key: string): NodePath;
  getPrevSibling(): NodePath;
  getNextSibling(): NodePath;
  getAllPrevSiblings(): NodePath[];
  getAllNextSiblings(): NodePath[];
  get<K extends keyof T>(key: K, context?: boolean | TraversalContext):
      T[K] extends Array<t.Node | null | undefined> ? Array<NodePath<T[K][number]>> :
      T[K] extends t.Node | null | undefined ? NodePath<T[K]> :
      never;
  get(key: string, context?: boolean | TraversalContext): NodePath | NodePath[];
  getBindingIdentifiers(duplicates?: boolean): t.Node[];
  getOuterBindingIdentifiers(duplicates?: boolean): t.Node[];
  getBindingIdentifierPaths(duplicates?: boolean,
    outerOnly?: boolean): NodePath[];
  getOuterBindingIdentifierPaths(duplicates?: boolean): NodePath[];

  matchesPattern(pattern: string, allowPartial?: boolean): boolean;
  has(key: string): boolean;
  isStatic(): boolean;
  is(key: string): boolean;
  isnt(key: string): boolean;
  equals(key: string, value: any): boolean;
  isNodeType(type: string): boolean;
  canHaveVariableDeclarationOrExpression(): boolean;
  canSwapBetweenExpressionAndStatement(replacement: t.Node): boolean;
  isCompletionRecord(allowInsideFunction?: boolean): boolean;
  isStatementOrBlock(): boolean;
  referencesImport(moduleSource: string, importName: string): boolean;
  getSource(): string;
  willIMaybeExecuteBefore(path: NodePath): boolean;
  // TODO: what type is resolved?
  resolve(dangerous?: boolean, resolved?: object): void;
  isConstantExpression(): boolean;
  isInStrictMode(): boolean;

  insertBefore(nodes: t.Node | t.Node[]): any;
  insertAfter(nodes: t.Node | t.Node[]): any;
  updateSiblingKeys(fromIndex: number, incrementBy: number): void;
  unshiftContainer(listKey: string, nodes: t.Node | t.Node[]): any;
  pushContainer(listKey: string, nodes: t.Node | t.Node[]): any;
  hoist(scope?: Scope): void;

  remove(): void;

  replaceWithMultiple(nodes: t.Node[]): void;
  replaceWithSourceString(replacement: any): void;
  replaceWith(replacement: t.Node | t.NodePath): void;
  replaceExpressionWithStatements(nodes: t.Node[]): t.Node;
  replaceInline(nodes: t.Node | t.Node[]): void;

  getTypeAnnotation(): t.TypeAnnotation;
  isBaseType(baseName: string, soft?: boolean): boolean;
  couldBeBaseType(name: string): boolean;
  baseTypeStrictlyMatches(right: NodePath): boolean;
  isGenericType(genericName: string): boolean;
${isEntries.join("\n")}
${assertEntries.join("\n")}
}

export class Binding {
  constructor(opts: {
    identifier: t.Identifier;
    scope: Scope;
    path: NodePath;
    kind: 'var' | 'let' | 'const';
  });
  identifier: t.Identifier;
  scope: Scope;
  path: NodePath;
  kind: 'var' | 'let' | 'const' | 'module';
  referenced: boolean;
  references: number;
  referencePaths: NodePath[];
  constant: boolean;
  constantViolations: NodePath[];
  hasDeoptedValue: boolean;
  hasValue: boolean;
  value: any;
}

export class Scope {
  constructor(path: NodePath);
  parent: Scope;
  parentBlock: t.Node;
  hub: Hub;
  path: NodePath;
  block: t.Node;
  bindings: { [name: string]: Binding; };

  traverse<S = t.Node>(node: t.Node | t.Node[],
    opts?: TraverseOptions<S>,
    state?: S): void;
  generateDeclaredUidIdentifier(name?: string): t.Identifier;
  generateUidIdentifier(name?: string): t.Identifier;
  generateUid(name?: string): string;
  generateUidBasedOnNode(parent: t.Node, defaultName?: string): t.Identifier;
  generateUidIdentifierBasedOnNode(parent: t.Node,
    defaultName?: string): t.Identifier;
  isStatic(node: t.Node): boolean;
  maybeGenerateMemoised(node: t.Node, dontPush?: boolean): t.Identifier;
  checkBlockScopedCollisions(local: t.Node, kind: string, name: string, id: object): void;
  rename(oldName: string, newName?: string, block?: t.Node): void;
  dump(): void;
  toArray(node: t.Node, i?: number): t.Node;
  hasLabel(name: string): boolean;
  getLabel(name: string): NodePath|undefined;
  registerLabel(path: NodePath): void;
  registerDeclaration(path: NodePath): void;
  buildUndefinedNode(): t.Node;
  registerConstantViolation(path: NodePath): void;
  registerBinding(kind: string, path: NodePath, bindingPath?: NodePath): void;
  addGlobal(node: t.Node): void;
  hasUid(name: string): boolean;
  hasGlobal(name: string): boolean;
  hasReference(name: string): boolean;
  isPure(node: t.Node, constantsOnly?: boolean): boolean;
  setData(key: string, val: any): any;
  getData(key: string): any;
  removeData(key: string): void;
  init(): void;
  crawl(): void;
  push(opts: {
    id: t.LVal,
    init?: t.Expression,
    unique?: boolean,
    kind?: 'var' | 'let'
  }): void;
  getProgramParent(): Scope;
  getFunctionParent(): Scope;
  getBlockParent(): Scope;
  getAllBindings(): object;
  getAllBindingsOfKind(...kinds: string[]): object;
  bindingIdentifierEquals(name: string, node: t.Node): boolean;
  getBinding(name: string): Binding | undefined;
  getOwnBinding(name: string): Binding | undefined;
  getBindingIdentifier(name: string): t.Identifier;
  getOwnBindingIdentifier(name: string): t.Identifier;
  hasOwnBinding(name: string): boolean;
  hasBinding(name: string, noGlobals?: boolean): boolean;
  parentHasBinding(name: string, noGlobals?: boolean): boolean;
  moveBindingTo(name: string, scope: Scope): void;
  removeOwnBinding(name: string): void;
  removeBinding(name: string): void;
}

export interface TraversalContext {
  parentPath: NodePath;
  scope: Scope;
  state: any;
  opts: any;
}

export interface Hub {
  getCode(): string|undefined;
  getScope(): Scope|undefined;
  addHelper(name: string): object;
  buildError(node: t.Node, msg: string, Error: object): object;
}

export type TraversalHandler<T, P> =
  (this: T, path: NodePath<P>, state: any) => void;

export interface TraversalHandlers<T> {
  enter?(path: NodePath<T>, state: any): void;
  exit?(path: NodePath<T>, state: any): void;
}

export type VisitNode<T, P> = TraversalHandler<T, P> | TraversalHandlers<T>;

export interface Visitor<S = t.Node> extends TraversalHandlers<t.Node> {
${visitorEntries.join("\n")}
}

export interface TraverseOptions<S = t.Node> extends Visitor<S> {
  scope?: Scope;
  noScope?: boolean;
}

export default function traverse<S = t.Node>(parent: t.Node | t.Node[],
  opts: TraverseOptions<S>,
  scope: Scope,
  state: S,
  parentPath?: NodePath): void;
\n\n`;

process.stdout.write(code);
